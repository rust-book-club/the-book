# Chapter 11: Writing Automated Tests

## How to Write Tests

### The Anatomy of a Test Function

> _"At its simplest, a test in Rust is a function that’s annotated with the `test` attribute."_

We used the `derive` attribute in Chapter 5.

To write and run a test
- add `#[test]` on the line before the `fn`
- call `cargo test`

When creating a new library project with Cargo, an example test is added automatically

```rust
cargo new adder --lib
```

```rust
// adder/src/lib.rs
pub fn add(left: usize, right: usize) -> usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test] // the test runner will treat this function as a test
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
```

> _"Rust can compile any code examples that appear in our API documentation. This feature helps keep your docs and your code in sync! We’ll discuss how to write documentation tests in the [“Documentation Comments as Tests”](https://rust-book.cs.brown.edu/ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests) section of Chapter 14."_

> _"Tests fail when something in the test function panics. Each test is run in a new thread, and when the main thread sees that a test thread has died, the test is marked as failed."_

Use
- `assert!`, `assert_eq!`, `assert_ne!`, etc.

### Testing Equality with the `assert_eq!` and `assert_ne!` Macros

> _"Under the surface, the `assert_eq!` and `assert_ne!` macros use the operators `==` and `!=`, respectively. When the assertions fail, these macros print their arguments using debug formatting, which means the values being compared must implement the `PartialEq` and `Debug` traits. For structs and enums that you define yourself... this is usually as straightforward as adding the `#[derive(PartialEq, Debug)]` annotation to your struct or enum definition."_

### Adding Custom Failure Messages

> _"Any arguments specified after the required arguments are passed along to the `format!` macro..."_

So while

```rust
assert_eq!(4, add_two(3));
```

results in

```rust
  left: `4`,
 right: `5`', src/lib.rs:14:9
```

```rust
assert_eq!(4, add_two(3), "{} should equal {}", 4, add_two(3));
```

results in

```rust
  left: `4`,
 right: `5`: 4 should equal 5', src/lib.rs:14:9
```

### Checking for Panics with `should_panic`

> _"We do this by adding the attribute `should_panic` to our test function."_

```rust
#[test]
#[should_panic]
fn divide() {
    let zero = "".len();
    1 / zero;
}
```

Add an `expected` parameter to the `should_panic` attribute to ensure that not just panicking, but panicking for the expected reason:

```rust
#[test]
#[should_panic(expected = "attempt to divide by zero")]
fn divide() {
    let zero = "".len();
    1 / zero;
}
```

### Using `Result<T, E>` in Tests

You can also use `Result` / `Err` in tests instead of panicking

```rust
#[cfg(test)]
mod tests {
    #[test]
    // can't use #[should_panic] here
    fn it_works() -> Result<(), String> { // return type changes
        if 2 + 2 == 4 {
            Ok(()) // pass
        } else {
            Err(String::from("two plus two does not equal four")) // fail
        }
    }
}
```

> _"Writing tests so they return a `Result<T, E>` enables you to use the question mark operator in the body of tests, which can be a convenient way to write tests that should fail if any operation within them returns an `Err` variant."_

> _"To assert that an operation returns an `Err` variant_, don’t _use the question mark operator on the `Result<T, E>` value. Instead, use `assert!(value.is_err())`."_

## Controlling How Tests Are Run

`cargo run` compiles code and runs the resulting binary

`cargo test` compiles code in test mode and runs the resulting binary

default behaviour of `cargo test` is to
- run all tests in parallel
- swallow any output generated by project code for passing tests

```sh
cargo test --help -- --help
                     ^^^^^^ arguments after the -- go to the test binary
           ^^^^^^ arguments before the -- go to cargo test
```

### Running Tests in Parallel or Consecutively

Run tests with no parallelism

```sh
cargo test -- --test-threads=1
```

### Showing Function Output

Don't swallow stdout output

```sh
cargo test -- --show-output
```

### Running a Subset of Tests by Name

Running `cargo test` like

```sh
cargo test one_hundred
```

...will result in only tests whose `fn` name contains the substring `one_hundred` to be run.

> _"Also note that the module in which a test appears becomes part of the test’s name, so we can run all the tests in a module by filtering on the module’s name._

For example, the following two tests (plus others, possibly) would be run when `cargo test tests` is executed

```
running 2 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok
```

### Ignoring Some Tests Unless Specifically Requested

Use `#[ignore]` below `#[test]` to ignore a test.

All ignored tests can be run with `cargo test -- --ignored`

All tests, including ignored tests, can be run with `cargo test -- --include-ignored`

## Test Organization

The Rust community organizes tests intwo two categories
- unit tests: testing one module in isolation at a time; testing private interfaces
- integration tests: entirely external to your library, using only the public API

### Unit Tests

> _"You’ll put unit tests in the_ src _directory in each file with the code that they’re testing. The convention is to create a module named `tests` in each file to contain the test functions and to annotate the module with `cfg(test)`."_

#### The Tests Module and `#[cfg(test)]`

> _"...because integration tests go in a different directory, they don’t need the `#[cfg(test)]` annotation. However, because unit tests go in the same files as the code, you’ll use `#[cfg(test)]` to specify that they shouldn’t be included in the compiled result."_

#### Testing Private Functions

Rust's privacy rules allow you to test private functions, e.g.

```rust
pub fn add_two(a: i32) -> i32 {
    internal_adder(a, 2)
}

// this function is private
fn internal_adder(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
```

### Integration Tests

> _"In Rust, integration tests are entirely external to your library. They use your library in the same way any other code would, which means they can only call functions that are part of your library’s public API."_

#### The _tests_ Directory

Cargo looks for integration tests in a `/tests` directory at the same level as `/src`.

Each test file in `/tests` becomes a separate crate.

> _"To run all the tests in a particular integration test file, use the `--test` argument of `cargo test` followed by the name of the file"_

```rust
cargo test --test integration_test
```

#### Submodules in Integration Tests

To create some helper methods to share across multiple integration tests, put them in a subdirectory of `tests`. So rather than

```
└── tests
    ├── common.rs           <- this will be interpreted as an integration test suite
    └── integration_test.rs
```

do

```
└── tests
    ├── common
    │   └── mod.rs          <- this will not be compiled or run as a test suite
    └── integration_test.rs <- but the methods in common/mod.rs can be used here
```

#### Integration Tests for Binary Crates

Integration tests cannot exist for projects with only a `src/main.rs` file (binary-only projects), because that code cannot be brought into scope with a `use` statement.

So the recommended pattern is for `src/main.rs` to only be a minimal wrapper around the main source code, in `src/lib.rs`. Then, integration tests can use the code in `src/lib.rs`.